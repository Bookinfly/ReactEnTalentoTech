El carrito y el cat√°logo son listas dentro de un objeto/array, necesito separar responsabilidades porque es un dolor de cabeza.

problemas:

üêû Problema estructural en la gesti√≥n del cat√°logo y carrito
üß© Resumen del problema
Actualmente, el contexto CartContext cumple dos funciones distintas:

Guarda el cat√°logo (listOfItems).

Guarda el carrito (cantItems, total).

Esta estructura no separa claramente el cat√°logo (datos fijos) de los datos del usuario (carrito).

‚ö†Ô∏è Consecuencias detectadas
Inestabilidad del carrito:

Las cantidades (cantItems) se almacenan directamente en memoria dentro del estado cartData.

Si se actualiza listOfItems (por fetch, cambio de sesi√≥n o error), tambi√©n se pierden las cantidades.

Dependencia posicional:

cantItems y listOfItems est√°n sincronizados por √≠ndice, no por id.

Esto es fr√°gil: si el orden cambia o un producto se elimina/agrega, se rompe la correspondencia.

Estado compartido entre componentes que no deber√≠an depender:

El componente de detalle o ciertas rutas pueden modificar cartData sin intenci√≥n, afectando otras vistas.

Problemas con persistencia:

Aunque cartData se guarda en localStorage, cualquier desincronizaci√≥n (por ejemplo, si se recarga desde otro fetch) sobrescribe los datos del usuario sin advertencia.

üîß Causa ra√≠z
Se ha mezclado el estado del cat√°logo (datos externos que no cambian con el usuario) con el estado del carrito (datos que s√≠ lo hacen). Esto dificulta:

Buscar o paginar productos sin afectar el carrito.

Renderizar con seguridad despu√©s de fetchs.

Persistir el carrito sin depender del cat√°logo.

‚úÖ Sugerencia para refactor futuro
Crear un modelo de contexto como este:

js
Copiar
Editar
{
  catalog: [...],       // Datos externos, tra√≠dos de la API
  cartItems: {          // Objeto indexado por ID del producto
    "id123": { cantidad: 2, producto: {} },
    "id456": { cantidad: 1, producto: {} }
  },
  total: 123.45
}
Esta separaci√≥n mejora la persistencia, la b√∫squeda, la paginaci√≥n y la robustez del sistema completo.

üõ†Ô∏è Soluci√≥n temporal aplicada
Se mantiene la estructura actual.

Se a√±ade buscador y paginador de forma no destructiva.

Se pospone la refactorizaci√≥n estructural a una rama paralela para evitar romper funcionalidades cr√≠ticas previas al despliegue.



